# 자료구조

* [Array와 Linked List](#array와-linked-list)
* [Stack과 Queue](#stack과-queue)
* [Tree](#tree)

---
</br>

## Array와 Linked List
### Array(배열)

* 논리적 저장 순서와 물리적 저장 순서 일치 -> `인덱스(index)`로 해당 원소에 `임의 접근(random access)` 가능 O(1)
* 삭제시 해당 원소 접근후(O(1)) `shift` 작업 추가 필요 이 경우 time complexity의 worst case는 O(n)
* 삽입시 위와 마찬가지로 `shift` 작업이 필요하다.

### ArrayList?

자바같은 프로그래밍 언어에서 보이는데 배열은 크기가 고정된거라면 이 친구는 가변

### Linked List

* 삽입 삭제 자체 속도가 빠름 O(1)
* 검색 시간이 길다. O(n)
* 삭제, 삽입을 하려면 검색을 하고 삽입 삭제를 하기 때문에 결론적으로는 O(n)이다
* 트리의 근간이 되는 자료구조

---
</br>


## Stack과 Queue

### Stack

* `Last In First Out (LIFO)`

### Queue

* `First In First Out(FIFO)`


---
</br>

## Tree

* 계층적 관계를 잘 표현한다.

### 용어

* `Node (노드)` : 트리를 구성하고 있는 각각의 요소를 의미한다.
* `Edge (간선)` : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.(Link, branch)
* `Root Node (루트 노드)` : 트리 구조에서 최상위에 있는 노드를 의미한다.
* `Terminal Node ( = leaf Node, 단말 노드)` : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다.
* `Internal Node (내부노드, 비단말 노드)` : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.
* `Sibling(형제)`: 같은 부모를 가지는 노드.
* 노드의 `크기(size)`: 자신을 포함한 모든 자손 노드 개수
* 노드의 `깊이(depth)`: 루트에서 해당 노드에 도달하기까지 거친 간선수
* 노드의 `차수(degree)`: 각 노드가 가진 가지의 수
* `트리의 차수(degree of tree)`: 트리의 최대 차수
* `레벨(level)`: 트리의 특정 깊이를 가지는 노드의 집합
* 트리의 `높이(height)`: 루트 노드에서 가장 깊이 있는 노드의 깊이

### Tree의 기본적인 성질

* 노드 N개 간선 N-1
* 임의의 두 노드 간의 경로는 유일하다.

### Binary Tree(이진 트리)

* 이진 트리에서 자식은 최대 2개
* 각각의 자식이 왼쪽 오른쪽 정해짐
* 높이가 h인 포화 이진 트리(full binary tree)는 2h−1개의 노드를 가진다
* 노드가 N개인 포화(full) 혹은 완전(complete) 이진 트리의 높이는 logN
* 노드가 N개인 이진트리의 높이는 최악의 경우 N

### 포화 이진 트리(Perfect Binary Tree)

모든 레벨에서 노드들이 모두 채워져 있는 트리
![](https://miro.medium.com/max/2000/1*fh2By4u-SxTlt6u2xHqnCg.png)

### 완전 이진트리(Complete Binary Tree)

왼쪽에서 오른쪽으로 차곡차곡쌓은 트리
![](https://miro.medium.com/max/2000/1*M1qfRR59TR9-i4pmI-_Clg.png)
### 정 이진 트리(Full Binary Tree) 

매 노드의 자식이 0 또는 2
![](https://miro.medium.com/max/2000/1*EgcvwUHXnmdOpbHQwgCknA.png)

### 변질 이진 트리(Degenerate(or Pathological) Binary Tree)

모든 노드의 자식 노드가 한개인 트리
![](https://miro.medium.com/max/2000/1*m5BjLJeSrSGH4US-QXj4aA.png)

### 균형 이진 트리(Balanced  Binaray Tree)

좌우측 하위 트리의 높이가 1이하인 경우
![](https://miro.medium.com/max/2000/1*jSq-xjEZYytNDIBpZNQC2w.png)

### 이진 탐색 트리 (BST, Binary Search Tree)

* 효율적인 탐색을 위한 저장 방법
* 왼쪽 < 부모 <  오른쪽
* 탐색 연산 O(log N), O(h)
* 편향 이진 트리의 경우 worst case가 되어 시간 복잡도가 O(n)이 된다.
배열보다 메모리를 많이 먹는데 시간 복잡도 같아짐
* 균형을 잡기 위해 재조정 `Rebalancing` 적용. 그 중한개가 `Red-Black Tree`

### 이진 힙(Binary Heap)

* 노드 값이 특정한 순서를 가지고 있는 `완전 이진 트리`
* `Max Heap`, `Min Heap`이 있다.
* `Max Heap`이란 각 노드의 값이 자식 노드의 값보다 크거나 같은 `완전 이진 트리`를 말한다. (`Min Heap`은 반대)
* `Max Heap`에서 루트 노드의 값이 최댓값이므로 최대값을 찾는데 O(1)
* `완전 이진 트리`이므로 배열을 사용하여 효율적으로 관리할 수 있다. 이 경우 제거된 루트 노드를 마지막 노드로 대체시킨후 heapify 과정을 거쳐 heap 구조를 유지시켜야한다. 이런 경우 결군 O(log n) 

### AVL Tree

* 위의 균형 이진 트리
* 균형이 무너진 유형 `LL`, `RR`, `LR`, `RL`
* 좌회전, 우회전을 이용하며 균형을 유지

#### LL

![](https://cdn.filepicker.io/api/file/SaR6jSSTYKuPCyuuGxlR)

#### RR

![](https://cdn.filepicker.io/api/file/njRUhO6MSZm0rn3Hv0l0)

#### RL과 LR(그림의 경우 RL)

![](https://cdn.filepicker.io/api/file/DQYwAvUlQ1mXC4MfW8eb)

### Red Black Tree
