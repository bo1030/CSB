# 자료구조

* [Array와 Linked List](#array와-linked-list)
* [Stack과 Queue](#stack과-queue)
* [Tree](#tree)

---
</br>

## Array와 Linked List
### Array(배열)

* 논리적 저장 순서와 물리적 저장 순서 일치 -> `인덱스(index)`로 해당 원소에 `임의 접근(random access)` 가능 O(1)
* 삭제시 해당 원소 접근후(O(1)) `shift` 작업 추가 필요 이 경우 time complexity의 worst case는 O(n)
* 삽입시 위와 마찬가지로 `shift` 작업이 필요하다.

### ArrayList?

자바같은 프로그래밍 언어에서 보이는데 배열은 크기가 고정된거라면 이 친구는 가변

### Linked List

* 삽입 삭제 자체 속도가 빠름 O(1)
* 검색 시간이 길다. O(n)
* 삭제, 삽입을 하려면 검색을 하고 삽입 삭제를 하기 때문에 결론적으로는 O(n)이다
* 트리의 근간이 되는 자료구조

---
</br>


## Stack과 Queue

### Stack

* `Last In First Out (LIFO)`

### Queue

* `First In First Out(FIFO)`


---
</br>

## Tree

* 계층적 관계를 잘 표현한다.

### 용어

* `Node (노드)` : 트리를 구성하고 있는 각각의 요소를 의미한다.
* `Edge (간선)` : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.(Link, branch)
* `Root Node (루트 노드)` : 트리 구조에서 최상위에 있는 노드를 의미한다.
* `Terminal Node ( = leaf Node,=external node, 단말 노드)` : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다.
* `Internal Node (내부노드, 비단말 노드)` : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.
* `Sibling(형제)`: 같은 부모를 가지는 노드.
* 노드의 `크기(size)`: 자신을 포함한 모든 자손 노드 개수
* 노드의 `깊이(depth)`: 루트에서 해당 노드에 도달하기까지 거친 간선수
* 노드의 `차수(degree)`: 각 노드가 가진 가지의 수
* `트리의 차수(degree of tree)`: 트리의 최대 차수
* `레벨(level)`: 트리의 특정 깊이를 가지는 노드의 집합
* 트리의 `높이(height)`: 루트 노드에서 가장 깊이 있는 노드의 깊이

### Tree의 기본적인 성질

* 노드 N개 간선 N-1
* 임의의 두 노드 간의 경로는 유일하다.

### Binary Tree(이진 트리)

* 이진 트리에서 자식은 최대 2개
* 각각의 자식이 왼쪽 오른쪽 정해짐
* 높이가 h인 포화 이진 트리(full binary tree)는 2h−1개의 노드를 가진다
* 노드가 N개인 포화(full) 혹은 완전(complete) 이진 트리의 높이는 logN
* 노드가 N개인 이진트리의 높이는 최악의 경우 N

### 포화 이진 트리(Perfect Binary Tree)

모든 레벨에서 노드들이 모두 채워져 있는 트리
![](https://miro.medium.com/max/2000/1*fh2By4u-SxTlt6u2xHqnCg.png)

### 완전 이진트리(Complete Binary Tree)

왼쪽에서 오른쪽으로 차곡차곡쌓은 트리
![](https://miro.medium.com/max/2000/1*M1qfRR59TR9-i4pmI-_Clg.png)
### 정 이진 트리(Full Binary Tree) 

매 노드의 자식이 0 또는 2
![](https://miro.medium.com/max/2000/1*EgcvwUHXnmdOpbHQwgCknA.png)

### 변질 이진 트리(Degenerate(or Pathological) Binary Tree)

모든 노드의 자식 노드가 한개인 트리
![](https://miro.medium.com/max/2000/1*m5BjLJeSrSGH4US-QXj4aA.png)

### 균형 이진 트리(Balanced  Binaray Tree)

좌우측 하위 트리의 높이가 1이하인 경우
![](https://miro.medium.com/max/2000/1*jSq-xjEZYytNDIBpZNQC2w.png)

### 이진 탐색 트리 (BST, Binary Search Tree)

* 효율적인 탐색을 위한 저장 방법
* 왼쪽 < 부모 <  오른쪽
* 탐색 연산 O(log N), O(h)
* 편향 이진 트리의 경우 worst case가 되어 시간 복잡도가 O(n)이 된다.
배열보다 메모리를 많이 먹는데 시간 복잡도 같아짐
* 균형을 잡기 위해 재조정 `Rebalancing` 적용. 그 중한개가 `Red-Black Tree`

### 이진 힙(Binary Heap)

* 노드 값이 특정한 순서를 가지고 있는 `완전 이진 트리`
* `Max Heap`, `Min Heap`이 있다.
* `Max Heap`이란 각 노드의 값이 자식 노드의 값보다 크거나 같은 `완전 이진 트리`를 말한다. (`Min Heap`은 반대)
* `Max Heap`에서 루트 노드의 값이 최댓값이므로 최대값을 찾는데 O(1)
* `완전 이진 트리`이므로 배열을 사용하여 효율적으로 관리할 수 있다. 이 경우 제거된 루트 노드를 마지막 노드로 대체시킨후 heapify 과정을 거쳐 heap 구조를 유지시켜야한다. 이런 경우 결군 O(log n) 

### AVL Tree

* 자가 균형 이진 트리
* 균형이 무너진 유형 `LL`, `RR`, `LR`, `RL`
* 좌회전, 우회전을 이용하며 균형을 유지

#### LL

![](https://cdn.filepicker.io/api/file/SaR6jSSTYKuPCyuuGxlR)

#### RR

![](https://cdn.filepicker.io/api/file/njRUhO6MSZm0rn3Hv0l0)

#### RL과 LR(그림의 경우 RL)

![](https://cdn.filepicker.io/api/file/DQYwAvUlQ1mXC4MfW8eb)

### Red Black Tree

* 자가 균형 이진 트리
* 연관 배열(맵, 사전...) 등을 구현하는데 사용됨
* 삽입, 삭제, 검색 O(log n)

#### 조건

* Root Property: 루트 노드이 색깔은 검정이다.
* External Property: 모든 단말 노드들은 검정이다.
* Internal Property: 빨강 노드의 자식은 검정이다. == 빨간색 노드 연속 x
* Depth Property: 모든 리프노드에 Black Depth는 같다. == 리프노드에서 루트 노드까지 가는 경로에서 만나는 검정노드의 개수는 같다.
* 삽입되는 노드는 빨간색

#### Restructuring(회전)

* Restructuring은 다른 서브트리에 영향을 끼치지 않기 때문에 한번의 Restructuring이면 끝남
* Restructuring은 어떤 노드를 insertion한 뒤 일어나므로 총 수행시간은 O(logn)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F998F903359CF65861762F8)

1. 나, 내 부모, 내 부모의 부모를 오름차순으로 정렬
2. 무조건 가운데 있는 값을 부모로 만들고 나머지 둘을 자식으로 만든다.
3. 올라간 가운데 값을 검정으로 만들고 자식을 빨강으로 만든다.
4. 나의 w를 추가한다.


#### Recoloring(색상 변환)
* 총 수행시간은 O(logn)
![](https://t1.daumcdn.net/cfile/tistory/9956CA3359CF658708?download)

1. 현재 inset된 노드(z)의 부모와 그 형제(w)를 검정(Black)으로 하고 Grand Parent(내 부모의 부모)를 빨강(Red)로 한다.
2. Grand Parent(내 부모의 부모)가 Root node가 아니었을 시 Double Red가 다시 발생 할 수 있다.(propagation이 될수도) -> 이 경우 반복해야함 최악의 경우 Root까지 갈수도

#### 삭제
* 빨강 삭제라면 다행
* 검정삭제면 검정 개수를 맞추기위해 여러 방법을 사용한다.

#### 결론

* Depth property 때문에 Balance가 맞다

