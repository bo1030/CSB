# 운영체제

* [개요](#개요)
* [운영체제 구조](#운영체제-구조) 
* [프로세스와 스레드](#프로세스와-스레드)

---
</br>

## 개요

운영체제란 `하드웨어를 관리하고, 응용 프로그램과 하드웨어 사이에서 인터페이스 역활을 하며 시스템의 동작을 제어하는 시스템 소프트웨어로 정의`한다.

즉 시스템의 자원과 동작을 관리하는 소프트웨어이다. 또한 사용자의 편의성을 높여준다.

### 컴퓨터 시스템 조직

* CPU: 계산을 실행
* I/O device: 디스크, 모니터, 프린터 등등
* 메모리: 프로그램과 데이터 저장
* 시스템 버스: 통신 채널

### 컴퓨터 부팅

* bootstrap program: 컴퓨터가 켜졌을때 가장먼저 켜지는 프로그램, ROM이나 EEPROM(firmware)에 저장되있음. CPU 레지스터나 디바이스 컨트롤러, 메모리를 초기화한다.
* 시스템 `데몬`: 백그라운드에서 커널이 돌아가는 전체 시간동안 켜져있다. `init`이 첫 프로세스이며 다른 `데몬`들을 시작시킨다.

### Firmware?

간단하게 하드웨어의 제어와 구동을 담당하는 프로그램

### 스토리지 구조

* 프로그램은 무조건 메모리에 로드된다.
* 폰노이만 구조
    * 인스트럭션과 데이터는 같은 메모리에 저장된다
    * CPU는 다양한 기능을 하는 장치이다. 메모리는 캐쉬를 사용하여 향상될수있다.

* 보조 저장장치: 메인 메모리가 작고 휘발성이 있어서 존재
* 저장 장치 계층(Storage device hierarchy)
* 비휘발 저장장치
    * SSD
    * flash memory
    * NVRAM: 배터리 보조 전원있는 RAM 

### I/O 구조

* 디바이스 컨트롤러
    * CPU와 디바이스 컨트롤러가 버스로 연결된다. ex) SCSI 컨트롤러
    * 자체적인 버퍼와 레지스터 존재한다.
    * 데이터 인/아웃을 책임진다.
    * OS는 디바이스 드라이버라는 디바이스 컨트롤러와 상호작용하는 것을 가지고 있다.
* I/O 작업
    1. 디바이스 드라이버가 디바이스 컨트롤러의 레지스터를 로드한다.
    2. 디바이스 컨트롤러는 레지스터 내용을 검사한다.
    3. 디바이스 컨트롤러가 데이터를 전송한다.
    4. 끝나면 컨트롤러가 인터럽트를 건다
    5. 드라이버가 운체에게 조절권을 돌려준다.
* DMA

### 컴퓨터 시스템 구조

* 단일 프로세서 시스템(single-processor)
    * 한개의 다목적 프로세서와 다양한 특수한 프로세서
* 다중 프로세서 시스템(multi-processor)
    * 왜 다중? 단일 프로세서로는 퍼포먼스를 더이상 향상 못시킴
    * 다중 프로세서의 장점
        * throughput 증가
* 비동기 멀티프로세싱: master와 slave

* 동기 멀티프로세싱(SMP)
    * 모든 프로세서가 peers
    * 모두 메모리를 공유한다.
* 멀티코어 시스템

## 운영체제 구조

### OS 인터페이스

* CLI
* GUI

### 시스템 콜

* 시스템 콜은 간단한 작업이라도 많이 쓰인다.
* 프로그램은 간접적으로도 시스템콜을 사용한다.
* 그럼 왜 API 사용?
    * 시스템 콜 바로 사용하면 위험
    * 이식성

### 시스템콜 인터페이스
시스템콜과 연결된 함수 라이브러리의 집합

### 시스템콜 종류

* 프로세스 관리
* 파일 조작
* 디바이스 조작
* 정보 관리
* 통신
* 보호

### 운영체제 디자인과 구현

* 디자인 목표
    * 유저: 사용 편의, 신뢰성, 속도
    * 시스템: 구현, 관리, 동작의 편의, 효율성, 유연성, fault-tolerant
* 가이드라인: 메커니즘과 정책
    * 메커니즘은 어떻게, 정책은 무엇을
    ex) timer 메커니즘, 스케쥴링 정책
    * 왜 분리함? 정책은 바뀜, 정책이 바뀐다고 메커니즘도 바뀌는건 좀 아니지 않나?

### OS 구현

* 어셈블리어: 복잡하다..., 어셈블리어는 CPU마다 다르기때문에 다른 PC에서 돌릴려면 에뮬레이터 필요
* 고급 언어: 구현이 편한고 컴파일러가 좋아져서 좋아짐, 에뮬레이터 필요없음, 성능이 좀 안좋음 -> 그래서 일부는 최적화시킴

### OS 구조

* 레이어 구조
* 마이크로커널

## 프로세스와 스레드

### 프로세스(Process)

* 실행중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU를 할당 받을 수 있는거
* 운체로부터 주소 공간, 파일, 메모리 등을 할당 받으며 이것들을 프로세스라고 한다.
* 프로세스 스택과 전역 변수를 수록하는 데이터 섹션을 포함한다. 또한 동적으로 할당되는 메모리인 힙을 포함한다.

### 프로세스 메모리

* 스택: 함수호출시 아래로 확장됨 
* 힙: 동적 할당시 위로 확장됨
* 데이터: 전역 변수
* 텍스트: 이진 프로그램 코드

공유하여 메모리 사용량을 줄임 -> Code는 같은 프로그램 자체에서는 모두 같은 내용, Stack과 data는 스택 구조의 특성과 전역 변수의 활용성 때문

### 프로세스 상태

* new
* running: 실행되는중, 한개의 프로세서에서는 한개만
* waiting: 이벤트 기다리는중 
* ready: 프로세서 할당대기중
* terminated: 종료됨

### PCB(프로세스 제어 블록)

* 특정 프로세스에 대한 중요한 정보를 저장하고 있는 것
* 프로세스의 생성과 동시에 고유한 PCB를 생성한다.
* CPU를 할당받아 작업을 처리하다 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU를 반환해야하는데 이때 작업의 진행사항을 PCB에 저장한다.
* 다시 CPU를 할당받으면 PCB에 저장된 내용을 불러온다.

### PCB에 저장되는 정보

* 프로세스 식별자(PID): 프로세스 식별번호
* 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
* 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
* 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
* CPU 레지스터
* CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
* 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
* 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
* 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

### 스레드(Thread)

* 스레드는 프로세스의 실행단위
* 프로세스 내에서 동작되는 여러 실행 흐름, 주소 공간이나 자원을 공유한다.
* 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성된다.
* 같은 프로세스에 속한 다른 쓰레드와 코드, 데이터, 열린 파일이나 신호와 같은 운영체제 자원들을 공유한다. 
* 하나의 프로세스를 다수의 실행단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 멀티스레딩이라고한다. 이 경우 각각의 스레드는 독립적인 작업을 수행해야하기 때문에 각자의 스택과 PC 레지스터 값을 갖고 있다.

### 스레드 VS 프로세스

* 프로세스는 자신만의 고유 공간과 자원을 할당받아 사용
* 스레드는 다른 스레드와 공간 자원을 공유하면서 사용

### 멀티 프로세스

* 여려 프로세스를 두고 동시에 처리함
* 장점: 안정성(메모리 침범 문제를 OS차원에서 해결)
* 단점: 각각 독립된 메모리 영역을 갖고있어, 작업량이 많을 수록 오버헤드 발생, Context Switshing으로 인한 성능 저하

### 멀티스레드

* 프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현
* 메모리 공간과 시스템 자원 소모가 감소
* 스레드간 통신이 필요한 경우에도 별도 자원 필요 없음
* 스레드의 context switch는 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.
* 시스템의 throughput(처리율)이 향상되고 자원 소모가 줄어들며 응답시간이 단축된다.

#### 단점

* 동일한 자원을 여러 스레드가 공유하기 때문에 엉뚱한 값을 불러오거나 저장하는 문제가 있다.
* 그래서 동기와 작업이 필요, 동기화를 통해 작업 처리 순서를 컨트롤, 그러나 병목현상이 발생할 수 있다.
* 안정성 문제, 하나의 스레드가 데이터 공간을 망가뜨리면 모든 스레드가 작동불능
* Critical Section(상호 배제, 진행, 한정된 대기를 충족) 기법으로 해결가능

### 프로세스 스케쥴링

* 멀티프로그래밍: CPU 활용도 최대로
* 시간 공유: 프로세스가 상호작용할 수 있도록

-> 프로세스 스케줄링

* 스케줄링 큐
    * job 큐: 모든 프로세스
    * ready 큐: 프로세서에서 작동되기를 기다리는 프로세스들, PCB의 연결리스트로 구현
    * device 큐: I/O 장치를 기다리는 프로세스의 리스트, 매장치마다 큐가 있음

### 스케줄러
* 큐에서 정책에 따라 프로세스를 선택해줌
* 장기 스케줄러: job 스케줄러
* 단기 스케줄러: CPU 스케줄러
* 장기 스케줄러는 I/O랑 CPU 바운드 프로세스를 잘조절해야한다
* 기준: CPU 활용도, 대기 시간, 응답시간, 공정성

### 인터럽트

* 프로그램을 실행하는 도중에 예기치 않을 상황이 발생할 경우 실행 중인 작업을 중단하고, 상황부터 처리가 필요하다고 CPU에게 알리는것
* 입출력, 우선 순위 연산 같은 일이...
* 외부/내부 인터럽트는 CPU의 하드웨어 신호(외부:전원 이상, 기계 착오, 외부 신호, 입출력 내부: Trap이라고 부르며, 잘못된 명령이나 데이터를 사용할때 발생)에 의해 발생
* 소프트웨어 인터럽트는 명령어의 수행에 의해 발생 (SVC 인터럽트)

### Context Switch?

* 프로세스의 상태 정보를 저장하고 복원하는 과정
* 프로세스는 각 독립된 메모리 영역을 할당받아 사용하므로 캐시 메모리 초기화로 오버헤드가 발생할 문제 존재 -> 줄이려면 콘텍스트 정보를 줄이면됨
* 하드웨어가 시간을 줄일수있다. 레지스터를 많이 두거나, 간단히 포인터를 바꿀수있는 등등

### 프로세스 종료

* exit()을 만나면 종료한다.
* 부모가 자식을 종료할수있다
* 좀비: 종료됬지만 부모 프로세스가 wait를 콜안한 경우 리턴에서 멈춰있다.
* 만약 절대 wait를 콜안하면? init이 받아서 wait를 콜해준다.

### IPC

* 프로세스간에 데이터 교환
* 공유메모리
* 메세지 전송

### 공유 메모리

* 프로세스가 주소공간에 메모리 구역을 준비하고
* 다른 프로세스의 주소공간에 그 공간을 붙인다.
* OS가 메모리 접근 제한을 풀어줘야된다.
* producer-consumer의 개념

### 메세지 전달 방식

* 직접 전송
* 간접 전송
* 왜 두개? 
    * 직접 통신의 경우 컴파일 할때 이름을 알수없거나 상대방의 이름이 달라지면 문제가 생긴다.
    * 그래서 메일 박스(간접 전송) 등장
    * 메일 박슨는 동기화 문제가 생김
* synchronization: 동기 중간중간에 확인하는거
* asyncho..: 비동기 결과만 받음
* blocking: 상대가 끝날때까지 기다리고만 있음
* nonblocking: 나도 일할수있어

### 소켓
* 통신을 위한 endpoint
* IP+port
* 서버Ip+port, 크라이언트IP+port, 프로토콜로 통신함

### 파이프
* 파이프로 통신가능, 단방향임
* Named pipe
    * FIFO라고도 함
    * 자식, 부모 관계없음
    * 여러 프로세스가 사용가능
    * 프로세스의 생명주기에 안묶임
    * mkfifo()

#### 인터럽트 발생 처리 과정
