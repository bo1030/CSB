# DB

* [데이터베이스](#데이터베이스)
* [스키마](#스키마)
* [Index](#Index)
* [정규화](#정규화)

## 데이터베이스

1. 실시간 접근
    * 즉시 응답
2. 계속적인 변화
    * DB는 동적이므로 현재의 정확한 데이터를 유지해야
3. 동시 공유
    * 동시에 여러 사용자가 접근할 수 있어야
4. 내용에 의한 참조
    * DB내의 데이터 레코드들은 값에 의한 참조

### DB의 기능

1. 데이터의 독립성
    * 물리적 독립성: 데이터베이스의 사이즈를 늘리거나 성능향상을 하더라도 응용 프로그램은 수정할필요없다.
    * 논리적 독립성: 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
2. 데이터의 무결성: 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.
3. 데이터의 보안성: 인가된 사용자만 데이터베이스나 데이터베이스내의 자원에 접근할수있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할수있다.
4. 데이터의 일관성: 연관된 정보를 논리적인 구조로 관리함으로써 데이터의 불일치성을 배제할 수 있다.
5. 데이터 중복 최소화: 데이터를 통합해서 관리함으로써 파일 시스템의 단점중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

### 데이터베이스의 구성요소

* **Entity**
* **Attribute**:
* **Relationship**

### Entity

* 반드시 엔터티가 사용되는 곳의 업무에서 필요하며 관리하고자 하는 정보
* 엔터티가 포함하는 인스턴스에 대해 유일한 식별자로 식별이 가능해야 함
* 엔터티는 지속적으로 존재하는 두개 이상의 인스턴스들의 조합이어야 함
* 엔터티는 반드시 속성을 지녀야 함
* 엔터티는 업무 프로세스에 의해서 이용되어야 함
* 엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 함

### Attribute

속성이란 인스턴스로 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 단위로 정의할 수 있다.
엔티티는 속성의 집합

### 속성의 분류

* 기본 속성: 현실세계로 부터 얻어낸 속성
* 설계 속성: 설계과정에서 나온 속성
* 파생(유도) 속성: 다른 속성으로 부터 나온 속성

### Relationship

상호 공유하는 속성이 있다.

### 관계의 카디널리티
두 엔티티간의 관계에서 참여자의 수를 표현한것

### 관계의 참여도
두 엔티티의 인스턴스들이 항상 관계에 참여하는지 아니면 경우에 따라 참여하는지 여부

### 데이터 베이스의 성능

* 디스크 I/O를 어떻게 줄이느냐
* 디스크의 성능은 디스크 헤더의 위치이동없이 얼마나 많은 데이터를 한 번에 기록하는냐에 따라결정
* 순차I/O가 랜덤보다 빠르다.
* 근데 현실은 순차보다는 랜덤->쿼리 튜닝은 랜덤 I/O를 줄여주는 것이 목적

## 스키마
* 데이터 구조와 제약 조건에 관한 명세를 기술한것
* Dtat Dictionary에 저장됨

1. 외부 스키마
    * View 개인의 견해
    * 전체 데이터베이스의 한 논리적인 부분
    * 응용 프로그래머가 접근하는 DB
    * 전체의 논리적인 일부분
2. 개념 스키마
    * 기관 전체의 견해
    * 모든 응용에 대한 전체적인 통합된 데이터 구조
    * 데이터 객체, 이들의 성질, 이들 간의 관계 데이터 관계들이 갖는 제약 조건에 관한 정의
    * 데이터 베이스 당 하나만 존재
3. 내부 스키마
    * 저장 장치의 견해
    * 개념 스키마에 대한 저장 구조를 정의한다.
    * 저장 형태의 표현
    * 저장될 내부 레코드의 형식, 인덱스의 유무, 내부 레코드이 물리적인 순서 명세

### 매핑

### 논리적 데이터 독립성

### 물리적 데이터 독립성


## Index

### 인덱스란 무엇인가?

* 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어둠
* DBMS의 인덱스는 항상 정렬된 상태를 유지한다. -> 원하는 값 탐색하는데 빠를것, 새로운값 추가, 삭제는 느려진다.
* 인덱스는 데이터의 저장성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능
* 모두 인덱스를 생성하면 데이터 저장성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.

### Index 자료구조

* B +-Tree 인덱스 알고리즘: 인덱스는 칼럼의 값을 변형하지 않고, 원래의 값을 이용하여 인덱싱하는 알고리즘
* Hash 인덱스 알고리즘: 칼럼의 값으로 해쉬값을 계산해서 인덱싱한다. 전방 일치와 같은 값의 일부만 같은경우를 찾는것은 힘들다. 메모리 기반의 데이터베이스에서 만이 사용한다.
* 왜 B-tree를 사용하는가? 부등호 연산이 hash테이블에 적합하지 않다.

### Primary Index vs Seconday Index

* 클러스터란 여러개를 하나로 묶는다.
* 클러스터드 인덱스는 테이블의 프라이머리 키에 대해서 키값이 비슷한 레코드끼리 묶어서 저장하는것을 클러스터드 인덱스라고 표현한다.
* 이경우 프라이머리 키 값이 변경되면 저장 위치또한 변경되어야한다.
* 테이블당 한개만 가능

### Composite Index

* select 질의를 어떻게 할것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 된다.

### Index의 성능, 고려해야할 사항

* INDEX를 생성하면 인덱스에 대한 데이터도 추가해야한다. 삭제 되더라도 그 인덱스는 남아서 삭제되지 않는다.
* 컬럼을 이루고 있는 데이터 형식에 따라 성능이 갈린다.

## 정규화
