# DB

* [데이터베이스](#데이터베이스)
* [Index](#Index)

## 데이터베이스

1. 데이터의 독립성
    * 물리적 독립성: 데이터베이스의 사이즈를 늘리거나 성능향상을 하더라도 응용 프로그램은 수정할필요없다.
    * 논리적 독립성: 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
2. 데이터의 무결성: 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.
3. 데이터의 보안성: 인가된 사용자만 데이터베이스나 데이터베이스내의 자원에 접근할수있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할수있다.
4. 데이터의 일관성: 연관된 정보를 논리적인 구조로 관리함으로써 데이터의 불일치성을 배제할 수 있다.
5. 데이터 중복 최소화: 데이터를 통합해서 관리함으로써 파일 시스템의 단점중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

### 데이터 베이스의 성능

* 디스크 I/O를 어떻게 줄이느냐
* 디스크의 성능은 디스크 헤더의 위치이동없이 얼마나 많은 데이터를 한 번에 기록하는냐에 따라결정
* 순차I/O가 랜덤보다 빠르다.
* 근데 현실은 순차보다는 랜덤->쿼리 튜닝은 랜덤 I/O를 줄여주는 것이 목적

## Index

### 인덱스란 무엇인가?

* 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어둠
* DBMS의 인덱스는 항상 정렬된 상태를 유지한다. -> 원하는 값 탐색하는데 빠를것, 새로운값 추가, 삭제는 느려진다.
* 인덱스는 데이터의 저장성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능
* 모두 인덱스를 생성하면 데이터 저장성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.

### Index 자료구조

* B +-Tree 인덱스 알고리즘: 
* Hash 인덱스 알고리즘: 칼럼의 값으로 해쉬값을 계산해서 인덱싱한다. 전방 일치와 같은 값의 일부만 같은경우를 찾는것은 힘들다. 메모리 기반의 데이터베이스에서 만이 사용한다.
* 왜 B-tree를 사용하는가? 부등호 연산이 hash테이블에 적합하지 않다.