# DB

* [데이터베이스](#데이터베이스)
* [스키마](#스키마)
* [트랜잭션](#트랜잭션)
* [DDL / DML / DCL](#DDL-/-DML-/-DCL)
* [무결성](#무결성)
* [Index](#Index)
* [정규화](#정규화)
* [DB설계](#DB설계)
* [관계데이터 제약](#관계데이터-제약)
* [DB 장애 관련](#DB-장애-관련)

## 데이터베이스

1. 실시간 접근
    * 즉시 응답
2. 계속적인 변화
    * DB는 동적이므로 현재의 정확한 데이터를 유지해야
3. 동시 공유
    * 동시에 여러 사용자가 접근할 수 있어야
4. 내용에 의한 참조
    * DB내의 데이터 레코드들은 값에 의한 참조

### DB의 기능

1. 데이터의 독립성
    * 물리적 독립성: 데이터베이스의 사이즈를 늘리거나 성능향상을 하더라도 응용 프로그램은 수정할필요없다.
    * 논리적 독립성: 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
2. 데이터의 무결성: 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.
3. 데이터의 보안성: 인가된 사용자만 데이터베이스나 데이터베이스내의 자원에 접근할수있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할수있다.
4. 데이터의 일관성: 연관된 정보를 논리적인 구조로 관리함으로써 데이터의 불일치성을 배제할 수 있다.
5. 데이터 중복 최소화: 데이터를 통합해서 관리함으로써 파일 시스템의 단점중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

### 데이터베이스의 구성요소

* **Entity**
* **Attribute**:
* **Relationship**

### Entity

* 반드시 엔터티가 사용되는 곳의 업무에서 필요하며 관리하고자 하는 정보
* 엔터티가 포함하는 인스턴스에 대해 유일한 식별자로 식별이 가능해야 함
* 엔터티는 지속적으로 존재하는 두개 이상의 인스턴스들의 조합이어야 함
* 엔터티는 반드시 속성을 지녀야 함
* 엔터티는 업무 프로세스에 의해서 이용되어야 함
* 엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 함

### Attribute

속성이란 인스턴스로 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 단위로 정의할 수 있다.
엔티티는 속성의 집합

### 속성의 분류

* 기본 속성: 현실세계로 부터 얻어낸 속성
* 설계 속성: 설계과정에서 나온 속성
* 파생(유도) 속성: 다른 속성으로 부터 나온 속성

### Relationship

상호 공유하는 속성이 있다.

### 관계의 카디널리티

두 엔티티간의 관계에서 참여자의 수를 표현한것

### 관계의 참여도

두 엔티티의 인스턴스들이 항상 관계에 참여하는지 아니면 경우에 따라 참여하는지 여부

### 데이터 베이스의 성능

* 디스크 I/O를 어떻게 줄이느냐
* 디스크의 성능은 디스크 헤더의 위치이동없이 얼마나 많은 데이터를 한 번에 기록하는냐에 따라결정
* 순차I/O가 랜덤보다 빠르다.
* 근데 현실은 순차보다는 랜덤->쿼리 튜닝은 랜덤 I/O를 줄여주는 것이 목적

## 스키마

* 데이터 구조와 제약 조건에 관한 명세를 기술한것
* Dtat Dictionary에 저장됨

1. 외부 스키마
    * View 개인의 견해
    * 전체 데이터베이스의 한 논리적인 부분
    * 응용 프로그래머가 접근하는 DB
    * 전체의 논리적인 일부분
2. 개념 스키마
    * 기관 전체의 견해
    * 모든 응용에 대한 전체적인 통합된 데이터 구조
    * 데이터 객체, 이들의 성질, 이들 간의 관계 데이터 관계들이 갖는 제약 조건에 관한 정의
    * 데이터 베이스 당 하나만 존재
3. 내부 스키마
    * 저장 장치의 견해
    * 개념 스키마에 대한 저장 구조를 정의한다.
    * 저장 형태의 표현
    * 저장될 내부 레코드의 형식, 인덱스의 유무, 내부 레코드이 물리적인 순서 명세

### View?

* 가상 테이블이다.
* 뷰 자체는 데이터를 갖지 않지만, 기초 테이블의 데이터를 조회하고 수정할 수 있는 창과 같다.
* 뷰는 데이터 값이 아니라 실제적으로는 질의 문장만을 가진다.
* **물리적인 테이블을 근거한 논리적인 테이블 (물리적으로 존재하지 않음)**
* 뷰는 기본 테이블에서 파생된 객체로서 기본 테이블에 대한 하나의 쿼리문(뷰테이블 X, 뷰쿼리 O)
* 사용자에게 주어진 뷰를 통해서 기본 테이블을 제한적으로 사용하게 된다.
* 독립적인 index 불가능, CRUD에 제약이 있음.

### 뷰의 사용방법

* 하나의 테이블에서 특정한 조건에 맞는 레코드 들만 질의(QUERY)가능
* **하나의 테이블에서 특정한 컬럼들만 질의(QUERY)가능**

### 복합 뷰

* **- 여러 테이블의 칼럼을 모아서(JOIN) 하나의 테이블처럼 질의(QUERY)할 수 있도록 한 데이터베이스 오브젝트**

### WITH CHECK OPTION / WITH READ ONLY 옵션 알아보기

* 조건 컬럼값을 변경하지 못하게 하는 옵션이다.

1. 뷰를 정의하는 서브 쿼리문에 WHERE절을 추가하여 기본 테이블 중 특정 조건에 만족하는 로우(행)만으로 구성된 뷰를 생성할 수 있다.

2. 이때 WHERE절에 WITH CHECK OPTION을 기술하면 그 조건에 의해 기본 테이블에서 정보가 추출하는 것이므로 조건에 사용 되어진 컬럼 값은

뷰를 통해서는 변경이 불가능하다.

### 매핑

* 외부/개념
  * 외부 스키마와 개념 스키마 간의 매핑
  * 외부 스키마의 데이터가 개념 스키마의 어느 부분에 해당하는기 대응

### 논리적 데이터 독립성

* 외부 스키마와 개념 스키마 사이의 독립성
* 개념스키마가 변경되어도 외부 스키마에는 영향을 미치지 않도록 지원
* 논리적 구조가 변경되어도 응용 프로그램에는 영향이 없도록 하는 개념
* 개념 스키마의 테이블을 생성하거나 변경하여도 외부 스키마가 직접 다루는 테이블이 아니면 영향이 없음

### 물리적 데이터 독립성

* 개념 스키마와 내부 스키마 사이의 독립성
* 저장장치 구조 변경과 같이 내부스키마가 변경되어도 개념 스키마에 영향을 미치지 않도록 지원
* 성능 개선을 위해 물리적 저장 장치를 재구성할 경우 개념 스키마나 외부스키마에 영향이 없음
* 물리적 독립성은 논리적 독립성보다 구현하기가 쉬움

## 트랜잭션

* DB 상태 변화 수행 작업 단위
* 하나의 트랜잭션은 커밋 되거나 롤백된다.

### 트랜잭션의 성질

* 원자성(atomicity): 연산이 모두 반영되거나 전혀 반영되지 않거나
* consistency: 일관성, DB의 상태를 일관적으로 유지, 스키마의 제약조건에 맞게 유지
* isolation: 트랜잭션 완료전에는 다른 트랜잭션 수행 결과 참조 불가
* durability: 영구적으로 반영

### 트랜잭션의 격리 수준

* 동시에 여러 트랜잭션 처리될때: 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 결정하는것

* READ UNCOMMITTED
  
  * 각 트랜잭션에서의 변경 내용이 `COMMIT`이나 `ROLLBACK` 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있다.
  * 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장한다.
  * 아래의 그림과 같이 `Commit`이 되지 않는 상태지만 `Update`된 값을 다른 트랜잭션에서 읽을 수 있다.
  * DIRTY READ 발생: 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상
* READ COMMITTED
  * RDB에서 대부분 기본적으로 사용되고 있는 격리 수준이다.
  * Dirty Read와 같은 현상은 발생하지 않는다.
  * 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다.
  * 문제점
    * `트랜잭션-1`이 Commit한 이후 아직 끝나지 않는 `트랜잭션-2`가 다시 테이블 값을 읽으면 값이 변경됨을 알 수 있다.
    * 하나의 트랜잭션내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 하는 `REPEATABLE READ`의 정합성에 어긋난다.
    * 이러한 문제는 주로 입금, 출금 처리가 진행되는 금전적인 처리에서 주로 발생한다.
    * 데이터의 정합성은 깨지고, 버그는 찾기 어려워 진다.
* REPEATABLE READ
  * MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.
  * Undo 공간에 백업해두고 실제 레코드 값을 변경한다.
    * 백업된 데이터는 불필요하다고 판단하는 시점에 주기적으로 삭제한다.
    * Undo에 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있다.
  * 이러한 변경방식은 [MVCC(Multi Version Concurrency Control)](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)라고 부른다.
  * 문제점
    * Phantom read
      * 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상
      * 이를 방지하기 위해서는 쓰기 잠금을 걸어야 한다.
* SERIALIZABLE
  * 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준
  * 성능 측면에서는 동시 처리성능이 가장 낮다.
  * `SERIALIZABLE`에서는 `PHANTOM READ`가 발생하지 않는다.하지만.. 데이터베이스에서 거의 사용되지 않는다.

### 트랜잭션 병행 처리시 발생 가능한 문제

1. 갱신 내용 손실
2. 현황 파악 오류 → 갱신 이전 조회
3. 모순성 → 일관성 없는 모순
4. 연쇄 복귀 → 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백

위의 문제 해결법 → **Locking제어**

### **Locking 제어**

* 로킹 단위를 크게 하면 관리가 쉽지만 병행성이 떨어짐.
* 로킹 단위가 작으면 관리가 어렵고 오버헤드가 증가.
* 문제점 → 트랜잭션의 직렬화 가능성이 높아질수 있음 (병행 처리의 의미가 없음), Deadlock발생 가능성

### Lock의 종류

### 공유(Shared) Lock

공유 Lock은 데이터를 읽을 때 사용되어지는 Lock입니다. 이런 공유 Lock은 공유 Lock 끼리는 동시에 접근이 가능합니다. 즉, 하나의 데이터를 읽는 것은 여러 사용자가 동시에 할 수 있다라는 것입니다. 하지만 공유 Lock이 설정된 데이터에 베타 Lock을 사용할 수는 없습니다.

### 베타 락

**베타 Lock은 데이터를 변경하고자 할 때 사용**되며, 트랜잭션이 완료될 때까지 유지됩니다. **베타락은 Lock이 해제될 때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없습니다.** 또한 해당 Lock은 다른 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 Lock을 설정할 수 없습니다.

### 락의 범위

* DB: 업데이트등등
* 파일
* 테이블: DDL 락이라고도 함
* 페이지와 블럭
* 컬럼
* 행

### 블록킹

락간의 경합이 발생하여 트랜잭션이 작업을 진행하지 못하고 멈춘상태 이전의 트랜잭션이 완료되어야 한다.

1. 한 트랜잭션의 길이를 너무 길게하는 것은 경합의 확률을 올립니다.
2. 처음부터 설계할 때 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 해야합니다.
3. 트랜잭션 격리성 수준을 불필요하게 상향 조정하지 않습니다. (참고 : [트랜잭션 격리성 수준](https://sabarada.tistory.com/117))
4. 쿼리를 오랜시간 잡아두지 않도록 적절한 튜닝을 진행합니다.

## DDL / DML / DCL

### DDL

DB를 정의하거나 그 정의를 수정할 목적으로 사용

* ALTER
* CREATE
* DROP
* TRUNCATE

### DML

사용자로 하여금 적절한 데이터 모델에 근거하여 데이터를 처리할 수 있게 하는 도구로서 사용자와 DBMS사이의 인터페이스 제공

* SELECT
* INSERT
* UPDATE
* DELETE

### DCL

데이터 보안 및 권한, 데이터 무결성 유지, 병행수행 제어, 데이터 회복기법

* GRANT
* REVOKE
* COMMIT
* ROLLBACK

## 무결성

* **개체 무결성** → 모든 테이블이 기본키 필드를 가져야한다. 기본키 필드는 고유한 값을 가져야하고, NULL은 허용되지 않음.
* **참조 무결성** → 참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지.
* **도메인 무결성** → 테이블에 존재하는 필드의 무결성을 보장. 올바른 데이터가 입력되었는지 확인 (ex : 주민등록번호 필드의 알파벳 입력 불가능하게)

## Index

### 인덱스란 무엇인가?

* 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어둠
* DBMS의 인덱스는 항상 정렬된 상태를 유지한다. -> 원하는 값 탐색하는데 빠를것, 새로운값 추가, 삭제는 느려진다.
* 인덱스는 데이터의 저장성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능
* 모두 인덱스를 생성하면 데이터 저장성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.

### Index 자료구조

* B +-Tree 인덱스 알고리즘: 인덱스는 칼럼의 값을 변형하지 않고, 원래의 값을 이용하여 인덱싱하는 알고리즘
* Hash 인덱스 알고리즘: 칼럼의 값으로 해쉬값을 계산해서 인덱싱한다. 전방 일치와 같은 값의 일부만 같은경우를 찾는것은 힘들다. 메모리 기반의 데이터베이스에서 만이 사용한다.
* 왜 B-tree를 사용하는가? 부등호 연산이 hash테이블에 적합하지 않다.

### Primary Index vs Seconday Index

* 클러스터란 여러개를 하나로 묶는다.
* 클러스터드 인덱스는 테이블의 프라이머리 키에 대해서 키값이 비슷한 레코드끼리 묶어서 저장하는것을 클러스터드 인덱스라고 표현한다.
* 이경우 프라이머리 키 값이 변경되면 저장 위치또한 변경되어야한다.
* 테이블당 한개만 가능

### Composite Index

* select 질의를 어떻게 할것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 된다.

### Index의 성능, 고려해야할 사항

* INDEX를 생성하면 인덱스에 대한 데이터도 추가해야한다. 삭제 되더라도 그 인덱스는 남아서 삭제되지 않는다.
* 컬럼을 이루고 있는 데이터 형식에 따라 성능이 갈린다.

## 정규화

* **정규화** : 데이터의 중복을 최소화하고, 삽입, 삭제, 갱신 과정의 이상 현상 방지를 위해 데이터를 **분해**하는 작업
* 역 정규화 : 정규화를 진행할수록 테이블을 여러 개로 나누게 되는데, 데이터 호출 시 여러 테이블을 불러서 JOIN해야 할 경우 역 정규화

### 정규화의 단계

* **제 1정규화** → 각 column들이 원자값을 가지게 바꾼다
* **제 2정규화** → 테이블의 모든 column에서 부분 함수적 종속 제거
* **제 3정규화** → 기본키를 제외한 속성들 간의 이행적 함수 종속 제거
* 제 BCNF화 → 결정자이면서 후보키가 아닌 것 제거
* 제 4정규화 → 다치 종속 제거

### 이상 현상

1. **갱신 이상** (Modification Anomaly) : 반복된 데이터 중에 일부를 갱신 할 시 데이터의 불일치가 발생한다.
2. **삽입 이상** (Insertion Anomaly) : 불필요한 정보를 함께 저장하지 않고서는 어떤 정보를 저장하는 것이 불가능하다.
3. **삭제 이상** (Deletion Anomaly) : 필요한 정보를 함께 삭제하지 않고서는 어떤 정보를 삭제하는 것이 불가능하다.

## DB 설계

1. **요구 조건 분석 단계**
    * 데이터 및 처리 요구 조건
2. **개념적 설계 단계**
    * 개념적 스키마 모델링
    * 트랜잭션 모델링
3. **논리적 설계 단계**
    * 논리적 스키마 설계
    * 트랜잭션 인터페이스 설계
4. **물리적 설계 단계**
    * 물리적 구조 설계
    * 트랜잭션 세부 설계
5. **구현 단계**
    * DDL로 스키마 작성
    * 트랜잭션(응용프로그램) 작성

## 관계데이터 제약

### 최소성 유일성

* 최소성 : 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질
* 유일성 : 하나의 키 값으로 Tuple을 유일하게 식별할 수 있는 성질

1. 슈퍼 키 (Super Key) : 유일성 O, 최소성 X
2. 후보 키 (Candidate Key) : 유일성 O, 최소성 O
3. 기본 키 (Primary Key) : 후보 키 중 선택 받은 키
    1. 널 값을 가질 수 있는 속성이 포함된 후보 키는 기본 키로 부적절 합니다.
    2. 값이 자주 변경될 수 있는 속성이 포함된 후보키는 기본키로 부적절 합니다.
    3. 단순한 후보 키를 기본 키로 선택합니다.
4. 대체 키 (Alternate Key)  : 후보 키 중 선택 받지 못한 키
5. 외래 키 (Foreign Key) : 다른 Relation의 기본 키를 참조, 존재이유는 데이터 무결성 때문입니다. 여기서 무결성이란 데이터가 항상 정확한 값을 유지하는 성질을 의미합니다.

## DB 장애 관련

* 트랜잭션 장애 : 트랜잭션을 정상적으로 완료하지 못함
* 시스템 장애 : HW/SW고장
* 디스크 장애 : Disk, Storage 고장

### 회복 기법

* **로그기반** 회복기법
* **지연 갱신** : write연산 지연, 트랜잭션 완료 시 로그를 보고 write연산 수행, 트랜잭션 완료시 장애가 발생하면 REDO 실행
* **체크포인트**
* **즉시 갱신** : 즉시 DB변경, 장애 발생 시 로그에 기반하여 UNDO 실행
* **그림자 페이징**

