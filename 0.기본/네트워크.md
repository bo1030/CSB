# 네트워크

* [개요](#개요)
* [네트워크 모델](#네트워크-모델)
* [데이터링크층](#데이터링크층)
* [연결기기와 가상랜](#연결기기와-가상랜)
* [네트워크층](#네트워크층)
* [유니캐스트 라우팅](#유니캐스트-라우팅)
* [트랜스포트층](#트랜스포트층)

## 개요

* 메세지: 통신의 대상이 되는 정보
* sender: 보내는 장치
* receiver: 받는 장치
* medium: 경로, twisted pair wire, coaxial cable, 광캐이블, 레이저, 무선
* protocol: 통신 규약

### data representation

* text: 비트 패턴
  * 코드: 부호를 표현하기 위한 비트 패턴의 집합
  * 코딩: 부호를 표현하기 위한 과정
* number: 비트 패턴을 사용하여 표현
* image: 픽셀, 해상도
* audio: 연속 신호(소리나 음악)
* vidieo: 연속적인 개체 또는 여러 화상의 조합

### data flow

* simplex mode: 한쪽 방향으로만 통신이 가능
* half-duplex mode: 각 지국들은 송수신 가능, 동시에 송신 불가
* full-duplex mode: 양쪽 지국간 동시에 송수신이 가능
양방향 통행이 가능한 2차선 도로와 같음, 신호는 링크의 용량을 공유해서 양방항으로 전달

### 네트워크란?

통신 링크에 서로 연결된 장치의 모임

* 노드: 호스트, end system, end host, connecting device sush as router
* 호스트: 네트워크에 연결된 컴퓨터

### 네트워크 성능 평가

* 퍼포먼스
  * 전송 시간
  * 반응 시간
  * 처리율
  * 지연
* 신뢰성
  * 고장의 빈도 수 고장 난 후 링크를 복구하는데 소요되는 시간
* 보안

### 물리적 구조: 연결 방식

* point-to-point: 두기기간의 전용 링크를 제공하는 구조
* multipoint 또는 multidrop: 3개 이상의 특정 기기가 하나의 링크를 공유하는 방식, 채널의 용량을 공간적으로 또는 시간적으로 공유

### 물리적 구조: 접속형태(topology)

* mesh 형
  * 모든 장치는 point-to-point 연결
  * n개의 장치를 서로 연결하기 위해 n(n-1)/2개의 채널이 요구
  * 장점
    * 원활한 자료전송 보장
    * 높은 안정성
    * 비밀 유지와 보안
    * 결함 식별과 분리가 비교적 용이
  * 단점
    * 케이블의 양과 요구되는 I/O 포트 수가 기하급수적으로 증가
    * 설치와 재구성의 어려움
* star 형
  * 허브라는 중앙제어장치와 point-to-point 링크 구성
  * 장점
    * mesh형보다 적은비용
    * 설치와 재구성이 용이
  * 단점
    * hub가 고장나면 전체 시스템 고장
* bus 형
  * multipoint 형태
  * tap과 drop line을 통해 bus에 연결
  * 장점
    * 설치가 쉽다.
    * 가장 적은양의 캐이블
  * 단점
    * 재구성이나 결함 분리의 어려움
    * 중추 케이블 고장시
* ring형
  * 자신의 양쪽에 위치한 친구와 point to point
    * 각노드는 리피터에 연결됨, 리피터는 신호증폭
  * 장점
    * 신호는 링을 따라 항상 순환하며, 설치와 재구성이 쉽다.
    * 일정시간내 신호가 수신되지 않을 시 위치를 경보함
  * 단점
    * 단방향의 경우 링의 결함시 전체 네트워크 마비
    * 이중 링 또는 결함 지점의 단절 스위치 사용을 통해 해결

### 네트워크 유형

* PAN
* LAN
* MAN
* WAN

### LAN

* 학교등 단일 기관의 컴퓨터들을 서로 연결하여 자원을 공유함
* 수 킬로미터까지 제한된 크기를 가짐
* star, bus, ring 구조를 사용

### WAN

* 국가 대륙 또는 전세계를 포괄하는 영역을 대상으로 데이터 음성, 영상 및 비디오 정보를 전송
* WAN의 종류
  * point to point WAN
  * Switched WAN
  * internetwork: 두개이상의 네트워크가 서로연결되어 있으면 internetwork 또는 internet

### 스위칭

* 2개 이상의 입력 단자와 출력 단자를 서로 연결시켜 주는 기능
* circuit switching과 packet switching으로 구분
* circuit switched network
  * 두 지점을 switch를 이용하여 물리적으로 접속시키는 방식
  * 종단 시스템간에 회선이라는 전용선을 이용
* packet switched network
  * 종단 간 통신은 packet이라는 데이터 블록에 의해 이루어짐
  * 송신 측에서 전송하는 데이터를 router에 저장시켰다가 이를 다시 적절한 통신경로를 선택하여 수신측 router에 전송
  * router가 store & forward로 packet을 전달함
  * packet을 저장하기위한 queue가 필요하며 더효율적임

### Internet

* 수천개의 상호연결되어 있는 네트워크로 이루어짐
* backbone: 큰 통신사 소유
* peering point라는 교환 시스템으로 backbone 연결
* provider network는 요금을 지불하고 backbone을 이용
* consumer nerwork는 인터넷 끝단으로써 인터넷에서 제공하는 서비스를 이용
* backbone과 provider network를 internet service provider(ISP)라고 함
  * backbone은 interwnational ISP라고함
  * provider network는 National 또는 Regional ISP라고 함

## 네트워크 모델

### protocol layering

* protocol: 송수신자, 모든 중간 장치들이 효과적으로 통신을 하기위해 지켜야할 규칙
* protocol layering: 통신이 복잡할때는 여러 계층을 두어 서로 다른 계층간에 임무를 나눌 수 있다
* 원칙
  1. 양방향 통신을 위해 각 계층은 서로 상반되는 두 가지 작업을 수행할 수 있다.
  2. 각 계층의 Object는 동일해야한다.

### logical connection

각 계층간 논리적인 연결은 계층대계층 통신을 갖는다는 의미

### TCP/IP 프로토콜 Suite

* TCP/IP: 인터넷에서 사용하는 5개 계층으로 구성된 모델
  * 어플리케이션 계층
    * 어플리케이션 계층 간에 메시지를 교환한다.
    * 두 프로세스간에 통신
    * 프로세스는 다른 프로세스에게 요처을하고 응답을 받는다.
    * HTTP, SMTP, FTP, SNMP, SSH, DNS, IGMP
  * 트랜스포트 계층
    * 어플리케이션 계층에서 메시지를 전달받아 캡슐화한다.
    * 논리적인 연결로 목적지의 트랜스포트 레이어에 보낸다.
    * end to end 노드 사이에 프로세스 to 프로세스로 메세지를 전달, 네트워크 레이어는 어느 프로세스로 전달해야하는지는 모름
    * tcp(흐름 제어, 오류제어, 혼잡제어 제공), udp(연결 x), sctp(멀티 미디어 서비스를 위하여 설계됨)
  * 네트워크 계층
    * 소스에서 목적지까지 packet을 전달한는 경로를 배정하여 packet을 전송하는 일을 담당
    * 흐름 제어, 오류 제어, 혼잡 제어 서비스를 제공하지 않는 비연결형 프로토콜
    * IP, ICMP, IGMP, DHCP, ARP
  * 데이터 링크
    * 유/무선 링크를 통하여 frame을 한 노드에서 다음 노드로 전달
  * 피지컬
    * frame의 각 bit를 전송 매체로 전달
    * 전송 매체에선느 전기 또는 광 신호로 전달
* 논리적 연결에서 각 계층의 의무범위
  * 응용층, 전송층, 네트워크층은 end to end, end는 호스트
  * 데이터 링크는 hop to hop hop은 host 또는 router

### encapsulation

* 상위계층의 프로토콜 정보를 하위계층의 프로토콜 정보 영역에 내장 시켜 전송
* Encapsulation at the Source Host
  * 상위계층꺼 하위계층에서 헤더 추가하고 다시 하위계층 전달
* Decapsulation & Encapsulation at the Router
  * 데이터링크 레이어에서 프레임을 decapsulation해서 네트워크 레이어 전달
  * 네트워크 레이어에서는 송수신 주소로 가지고 forwading table을 조사하여 datagram이 전달될 다음 hop을 찾는다.
  * 데이터그램을 다시 프레임으로하여 내려보내서 전달함
* Decapsulation at the Destination Host
  * 각 레이어에서는 decapsulation하고 페이로드를 다음 상위링크로 전달

### addressing

* 프로토콜 계층화와 관련하여 발신지와 목적지 사이에 4쌍의 주소를 사용
  * 메시지: 이름(이메일, URL같은거)
  * 세그먼트/유저 데이터그램: 포트 번호(프로세스에 부여함)
  * 데이터그램: 논리적 주소(IP 주소)
  * 프레임: 링크 레이어 주소(맥 주소)

### 멀티플렉싱, 디멀티플렉싱

* 멀티플렉싱
  * 발신지에서 하위계층의 프로토콜이 여러개의 상위계층 프로토콜을 처리하는 개념
  * 발신지에서 멀티플렉싱, 목적지에서 디멀티플렉싱이 필요

### OSI 모델

* ISO에서 제정한 개방 시스템 상호연결 모델
* 네트워크 시스템을 설계하기 위한 계틍 구조를 갖는 모델
* 7개층
  * application
  * presentaion
  * session
  * transport
  * network
  * datalink
  * physical
* TCP/IP 프로토콜이 많은 시간을 들여 완전히 자리를 잡은 후 OSI 완성
* OSI 일부 계층은 완전히 정의되지 않음
* OSI 계층이 전환을 위한 충분히 높은 수준을 보여주지 못함

## 데이터링크층

### 인터넷

* 네트워크의 조합
* 패킷이 한 호스트에서 다른 호스트로 이동한다면, 이런 네트워크들을 통해서 간다.

### 노드와 링크

* 데이터링크의 통신은 노드 to 노드이다.
* LANs 와 WANs는 라우터에 의해 연결된다.
* 호스트와 라우터는 노드, 그 중간은 링크

### 데이터링크의 서비스

* 데이터링크층은 물리층과 네트워크 층사이
* 서비스
  * 프레이밍: 데이터그램을 프레임으로 캡슐화
  * 흐름 제어: 프레임 생성비율은 소비율에 따라 조절되야됨
  * 에러 제어: 에러는 감지되어야하고, 조정 또는 버리고 재전송을 해줘야한다.
  * 혼잡 제어: 프레임들로 링크가 혼잡해질수있다. 대부분의 프로토콜은 직접적으로 혼잡 제어를 하지는 않는다.

### 링크의 두 카테고리

* Point-to-Point: 매체의 전체 용량을 사용
* 브로드캐스트 링크: 링크의 일부만 사용

### 데이커링크층의 두 서브레이어

* DLC: Point-to-Point와 브로드캐스트 링크 모두에서 일어나는 일을 처리
* MAC: 브로드캐스트에서만 일어나는 일을 처리

### 데이터링크층의 addressing

* IP주소는 네트워크층의 식별자이다. IP주소는 바뀌지 않는다.
* Ip주소만 가지고는 목적지에 도달못한다.
  * 두 IP주소는 두 끝단만 알려준다.
  * 어느 링크로 가야할지는 알려주지 않는다.
* 데이터그램이 데이터링크로 내려왔을때
  * 프레임으로 캡슐화된다.
  * 링크-레이어 주소는 프레임 헤더에 추가된다.
* 링크 주소, 물리 주소, 맥 주소, 이더넷 주소, 하드웨어 주소, 어뎁터 주소....등등 같은 말임
* 작은 네트워크에서 Ip와 링크레이어 주소: 링크레이어주소는 프레임이 한링크를 움직일때마다 달라진다.

### 세종류의 주소

* 링크 레이어 프로토콜은 세종류의 주소를 가진다.
  * 유니캐스트: 1대1 통신
    * 두번째 digit이 짝수
  * Multicast Address: 1대다 통신
    * 두번째가 홀수
    * 관할구역은 지역
  * 브로드캐스트: 1대전부
    * 48 비트모두 1
    * 링크의 모두에게 전달

### Address Resoultion Protocol(ARP)

* 다른 노드에게 전달할 IP 데이터그램이 있을때, 받는 노드의 IP 주소를 가지고 있다.
  * 다음 노드의 IP 주소는 링크를 통해 프레임을 보내는데 부적합하다
  * 링크레이어주소를 찾기위한 프로토콜이다.
* ARP: IP주소에대한 MAC주소 알수있다. 네트워크층에 속한다.

### DLC

* 두 인접 노드간에 통신할때 절차를 처리해줌

### 프레이밍

* bits들을 어떻게 구성할지
* 패킷을 센더와 리시버의 주소를 추가하여 구분한다.
* CRC(Cyclic redundacy check)
  * 에러 감지 코드
  * 센더에서 체크값을 추가한다.
  * 리시버에서 체크값이 안맞으면 데이터가 오염된거
* 프레임 사이즈
  * 고정 사이즈
  * 변동 사이즈: 바이트 기반 프레임, 비트 기반 프레임
* bit oriented framing
  * 비트들로 데이터 구성
  * flag 01111110이 있다.
* bit stuffing
  * 5개 1이 연속되면 0추가
  * flag로 구분되지않게 하려고 추가

### 에러와 흐름 제어

* 흐름 제어
  * 생산과 솝지가 균형이 맞아야됨
  * buffer를 사용한다.
* stop and wait 프로토콜
  * 한번에 1개씩 보낸다. 데이터링크 레이어에서 사용됨
* sliding window 프로토콜
  * 트랜스포트 레이어에서 사용됨 여러 프레임을 한번에 보냄
* 에러 제어
  * CRC
  * 오염되면 버린다.
  * 정상이면 acknowledge보낸다.
* simple protocol
* stop and wait protocol
* go back n protocol
* selective repeat protocol
* 처음 2개만 사용됨

### 심플 프로토콜

* 흐름제어랑 에러제어 안함

### stop and wait 프로토콜

* 흐름과 에러 제어함
* CRC를 각 데이터 프레임에 추가한다.
* 프레임 보내고 타이머 시작한다.
  * 만약에 ACK 도착하면 다음 프레임 보내고 타이머 초기화한다.
  * 타이머 끝나면 다시 보낸다.
* ACK 도착하기 전에는 프레임을 복사해둬야한다.

### 피기백

* 단방향 통신이다. 데이터는 한방향으로 흐르지만 ack는 다른 방향으로 갈수도 있다.
* 프로토콜은 양방향 통신을 허용하게 디자인됨
  * 효율적으로 통신하기위해 ACK를 추가해서 보낸다.

### Media Access Control

* 다중 접근
  * random access: ALOHA, CSMA/CD, CSMA/CA
  * Controlled-access: Reservation, Polling, Token passing
  * Channelization: FDMA, TDMA, CDMA

### Random Access

* 모든 station이 동등
* 보낼지 안보낼지 결정한다.

### ALOHA

* 순수: 걍 보내고 ACK 안오면 다시보낸다.
* slotted: 슬롯에 맞춰서 보낸다.

### CSMA

* 회선을 감지하고 있다가 비면 보낸다.
* 1-persistent: 바로 보낸다.
* Non-persistent: 일정시간 보내고 한다.
* p-persistent: 바쁘면 연속적으로 감지하다가 비면 P를 바탕으로 보낸다.

### CSMA/CD

* 충돌 감지 추가
* 보낼때도 감시한다.
* 충돌이 있다면 다시 보낸다.

### 채널화

* FDMA(주파수로 나누기)
* TDMA(시간으로 나누기)
* CDMA(코드로 나누기)

## 연결기기와 가상랜

* 이더넷
  * 이더넷 프레임 7필드

### 연결 기기

* 10base5
* 10base2
* 10base-T

### 허브, 리피터, 브릿지

* 허브는 물리레이어
* 리피터는 신호를 받고 다시 만들어서 보낸다.
* 브릿지는 다른 네트워크 속도에서도 연결됨 collision domain을 나눠줌

### 스위치(L2)

* 데이터링크층
* 맥주소를 바탕으로 링크연결해줌
* 테이블을 관리함
* N port 브릿지임

### 스위치의 5가지 기능

* learning: MAC address table 학습
  * 루프 문제
  * 스패닝 트리로 루프 문제를 해결함
* Flooding: 모든 포트에 뿌림
* Forwarding: 해당하는 포트로 뿌림
* filtering: 출발지랑 목적지가 같으면 안본낸다.

* full-duplex switched 이더넷
  * LLC와 MAC사이에 서브레이어를 추가했다.

### 라우터

* 라우터는 3개의 계층에서 작동한다.
* 스위치와 라우터의 차이
  * 라우터는 MAC과 IP주소 모두 가진다.
  * 라우터는 맞게 찾아온 MAC 주소만 처리해줌
  * 라우터는 링크레이어 주소를 교환해서 보낸다.

### VLAN

* LAN에 속한것처럼 해준다.
* 소프트웨어로 해준다.

* VLAN에서 그룹나눌때 사용하는것
  * 인터페이스 번호
  * 포트 번호
  * 맥 주소
  * 아이피 주소
  * 아이피 멀티캐스팅 주소
  * 그리고 위에꺼 조합하자
* 여러 스위치 사용할때
  * 어떤 station이 어떤 VLAN인지 알고있어야한다.
  * 어떤 station이 어느 스위치인지도 알고있어야함
* 장점
  * 비용 시간 절감
  * 가상 작업 그룹만들수있다.
  * 보안

## 네트워크층

### 네트워크층이 하는 일

* 패킷화: 패이로드 캡슐화, 디캡슐
* 라우팅, 포워딩
* 에러 컨트롤: 직접적으로 하지는 않음, 체크섬이 헤더의 오염을 조절해줌
* ICMP: 데이터그램이 삭제되거나 헤더에 알수있는 정보가 있으면 에러 제어같은 것을 제공해줌
* 흐름제어: 흐름 제어를 하려면 피드백을 보내야한다. 네트워크 층은 직접적으로 하지는 않는다. 트랜스포트 레이어가 해줌, 그래서 네트워크층에서 또하는건 복잡하게 만든다.
* QoS: 이것도 상위 레이어
* 보안: IPSec

### 라우터의 포워딩

* 포워딩 테이블에 출력 인터페이스 번호를 찾는다.
* 목적지 주소 또는 라벨이 포워딩 값이 될수있다.

### 라우팅과 포워딩

* 라우팅은 라우팅 알고리즘을 통해 decision-make 테이블을 만들어서 적용한다.
* 포워딩은 각 라우터에서 도착한 패킷에 적용한다.

### 패킷 스위칭

* 라우팅과 포워딩을 할때 스위칭이 일어난다.
* 라우터: 인풋 포트와 아웃풋 포트의 연결을 해주는 스위치이다.
* 데이터 그램 접근법: connectionless
* Virtual Circuit: connection

### 데이터그램 접근법

* Connectionless Oriented Service
  * 네트워크 레이어는 패킷 전송만 한다.
  * 원래는 연결없는 서비스를 제공했다.
    * 각 패킷은 다른 패킷과 연관이 없었다.
    * 같은 패스를 사용안해도 된다.
* 포워딩
  * 목적지 주소를 바탕으로 해준다.
  * 소스 주소는 패킷이 손실되면 에러메시지를 전달할때 사용한다.

### virtual-circuit 접근법

* Connection-oriented service
* 가상의 연결이 생기니다.
* 페킷은 소스/목적지주소와 흐름 라벨(VCI)을 가진다.
* 포워딩은 라벨을 바탕으로 한다.

### IPv4 주소

* IP 주소, 인터넷 주소
  * IP 계층에서 식별자로 사용된다.
  * 호스트와 라우터의 주소가 아니라 연결의 주소이다.
* 32bit주소
  * 클래스 A
  * 클래스 B
  * 클래스 C
  * 클래스 D
  * 클래스 E

### IP 주소 공간

* 주소 위계질서
  * prefix: network
  * suffix: 노드
* 고정된 prefix: classful 주소
* 변동 prefix: classless 주소

### classful 주소

* 고정된 prefix
* 3개의 고정된 prefixㄷ가 있다. 8(A), 16(B), 24(D)
* 인터넷의 성장으로 더 큰 주소 공간이 필요해졌다.-> classless(단기) IPv6(장기)

### classless 주소

* 변동 길이의 prefix를 제공한다.
* 여러 길이의 블록으로 나뉘다. 블록은 기관에게 할당된다.
* Classless inter-Domain Routing(CIDR)
  * prefix는 네트워크와 서브넷을
  * suffix는 호스트를 식별
* prefix 길이가 주어지면
  * /로 구분된다.
* 네트워크 주소
  * 각 네트워크는 네트워크 주소로 식별
  * 라우터에 도착하면 어느 네트워크로 보내야할지 알아야함
* 블록 할당
  * ICANN이 함
  * 블록 할당 규칙: 2의 거듭제곱 개, 첫주소는 주소 크기로 나눠져야됨
* 서브넷팅
  * 서브넷을 사용하면 더 많은 레벨이 생긴다.
  * 서브넷은 서브 서브넷으로 나눌수잇다.
* 주소 집계
  * 주소가 합쳐질때 큰 친구 따라서 라우팅함
  * ICANN은 ISP에게 더큰블록을 할당함
  * 각 ISP는 작은 subblock으로 할당함

### DHCP

* 어플리케이션층
* IP 동적할당
* 서버찾기, IP 대여 제안, 요청, 인정

### NAT

* 작은 네트워크와 인터넷을 이어줄때 필요
* NAT: 사설 주소와 universal 주소를 매핑해줌
* NAT은 라우터나 방화벽에서 구현됨
* 트랜스레이션 테이블

### IP 패킷의 포워딩

* 길이가 긴 서브넷부터

### MPLS

* MPLS 라우터 라우터와 스위치 같음
* MPLS 헤더는 서브헤더를 추가한다

### IP 프로토콜

* IP는 패킷화, 포워딩, 페킥 배송
* ICMP: 에러처리
* IGMP: 멀티캐스팅
* ARP: 어드레스 맵핑

### IPv4 데이터그램 포맷

* 패킷은 데이터그램이라고 불림
* 데이터그램의 길이는 변동됨

### 프래그멘테이션

* 각 라우터는 IP 데이터 그램을 디캡슐함, 다시 다른걸로 캡슐화
* 프레임의 크기와 포맷은 물리 계층에의해 결정됨
* MTU: 최대 크기랑 연관됨
* 플래그멘테이션: 조각내는거

### 데이터그램의 보안

* IPv4는 보안이 없음
* 이 프로토콜은 믿을수있는 유저들로 시작됨
* 3가지 문제
  * 패킷 스니핑
  * 패킷 변조
  * IP spoofing
* IPSec
  * 위의 문제 해결가능
  * AH(authentication header)
  * ESP(Encapsulating Security Payload)
  
## 유니캐스트 라우팅

위계질서적인 라우팅을 사용해서 된다.

### Least-Cost Routing

* 코스트가 제일 적은 길찾기
* N개의 라우터, N-1개의 길
* N(N-1)의 경우의수
* shortest path tree

### 라우팅 알고리즘

* Distance Vector Routing
* Link-State Routing
* Path-Vector Routing
* 차이점: 최소 비용의 해석, least-cost tree 생성법

### Distance-Vector Routing

* least-cost tree를 사용함
* 각 라우터는 벡타라고 알려진 디스턴스 테이블을 유지한다.
* 각 노드는 least-cost tree를 이웃에 관한 정보로 만든다.
* 성격
  * 라우터는 네트워크에 대한 정보를 가지는 distance vector를 가지고 있다.
  * 정보는 이웃끼리 공유한다.
  * 일정한 간경마다 업데이트한다.
* Bellman-Ford 방정식
  * 최소 비용을 찾는 공식
  * Dxy= min{ (Cxa + Day), (Cxb + Dby),(Cxc + Dcy), …}
* distance vectors
  * least-cost tree는 least-cost path의 조합
  * 이 알고리즘은 Distance Vector 만드는 과정이다.
* count-to-infinity
  * 한링크가 없을때 모든 라우터는 그것을 알아야한다.
  * 만약한개가 없어지면 점진적으로 +1이 된다. 무한대가 될때까지
* split horizon
  * 학습받은 정보를 다시 알려주는거 방지
  * flooding 대신에 일부분만 각 인터페이스에 맞게 전달
* poisoned reverse
  * count-to-infinity 문제를 해결할 수 있음
  * failed link 발견하면 무한대로 할당함 그리고 알려준다.
  * poisoned route를 받으면 split horizopn을 깨고 만든놈에게도 poisoned route정보를 보낸다. 이게 poisoned reverse

### Link-State 라우팅

* 포워딩 테이블과 least cost tree를 만든다.
* link-state는 링크의 특성을 정의한다.
  * 대역폭, 지연, 로드
  * 링크 cost와 연관 된다.
* LSP: 이웃과 각 링크의 비용이 들어있는 패킷, 플러딩으로 분배됨, LSDB를 만들때 사용
* LSDB: 각 라우터는 LSP를 모으고, 이것을 만든다. 모든 라우터에 대한 정보, Area의 모든 라우터는 같은 DB를 가진다.
* least-cost tree 구성
  * 각 노드는 다익스트라 SPF 알고리즘을 돌린다.
    * 노드는 자기를 루트로 둔다. 그리고 각 비용은 LSDB를 참고함
    * 루트로 부터 가까운 노드를 선택하고 트리에 추가한다.
    * 트리에 없는 모든 노드의 비용은 변화해야한다.
    * 위에꺼 반복
* 포워딩 테이블
  * LSDP에서 정보로 계산함
  * 가장 좋은 길을 보여줌
  * 라우터마다 다름

### Path-Vector 라우팅

* least-cost가 우선이 아닌 인스턴스가 있다.
* policy based Path-Vector routing
  * 가장 좋은 루트는 출발지에 의해 결정된다.
  * 인터넷에서 사용된다. ISP간에 패킷 라우팅을 설계함
* Spanning Tree
  * 목적지로 가는 길은 스패닝 트리로 결정됨
  * 정책을 도입한 출발지에 의해서 스패닝 트리는 결정된다.
* 스패닝 트리 생성
  * 노드가 켜지면, path-vector는 이웃에 의해 만들어진다.
    * 노는 인사 메시지를 보내서 정보를 모은다.
  * 각 노드는 path vector를 모든 이웃에게 보내고 업데이트한다.
  * 각 노드는 정책에 맞게 업데이트를 한다.

### 라우팅 프로토콜

* RIP(Rounting Information Protocol): distance vector 알고리즘를 사용한다.
* OSPF(Open Shortest Path First): link-state 알고리즘
* Border Gateway Protocol(BGP): path-vector 알고리즘

### 인터넷 구조

* ISP는 AS(Autonomous System)로 여겨짐
* 각 AS는 라우팅 프로토콜을 가지고 있다.
  * intra-AS(intra-domain, interior gateway) 라우팅 프로토콜 등등으로 불린다.
  * RIP와 OSPF를 사용
* 인터넷은 모든 AS들을 묶는 전역 프로토콜을 운영한다.
  * inter-AS(inter-domain, exterior gateway) 라우팅 프로토콜
  * BGP
* AS
  * stub AS
    * 다른 AS 한개의 연결만 있는것
    * 데이터는 시작되거나 마지막이다.
  * Multi-homed AS
    * 여러 연결이 있다.
    * 데이터가 통과하지는 못한다.
    * 여러 통신사를 사용하는 고객
  * transient AS
    * 데이터를 통과 시키는 AS
    * 통신사 네트워크 또는 백본
* ASBR(AS Boundary Router)
  * 다른 AS의 라우터와 라우팅 정보를 교환한다.
  * 여러 라우팅 프로토콜을 사용

### RIP

* AS 내부에서 사용되는 프로토콜
* XNS에서 시작됨
* UDP를 사용한다. 포트는 530, routed 데몬 프로세스를 돌려서 한다. 응용계층에서 포워딩 테이블 운용
* hop 개수
  * RIP는 다른 네트워크에 도달하는 비용을 알린다.
  * 비용은 Hop의 개수로 정의된다.
    * 출발지는 개수로 안 친다.
    * 최대 비용은 15
    * RIP는 AS 내부에서만 사용됨
* 포워딩 테이블
  * 첫번째 열: 목적지
  * 두번째 열: 다음 라우터
  * 세번째 열: 비용
* RIP 구현
  * UDP를 사용하는 프로세스로 구현됨. 데몬 프로세스이다.
* RIP 메시지
  * 요청: 특정 또는 모든 엔트리에게 물어봄, 방금 생긴 라우터나 time-out된 엔트리 라우터에서 보낸다.
  * 응답: 요청 메시지의 구체적인 목적지에 대한 정보를 담는다, 주기적으로 보내거나 포워딩 테이블이 변경될때 보낸다.
* 3개의 타이머
  * 주기 타이머: 메시지 업데이트(25~35 랜덤)
  * 타임아웃 타이머: 180초, 매 30초마다 업데이트가 일어나지만, 180초동안 업데이트가 없으면 라우터의 홉 개수를 16으로 바꿀지 고려한다.
  * GC 타이머: 120초, 라우터가 사용 불가능일때 바로 없애지는 않는다. 16으로 바뀐 라우터가 있으면 타이머를 설정하고 120 지나면 없앤다

### OSPF

* Link-State 라우팅 프로토콜인 내부 프로토콜
* LSDB를 유지
* 관리를 쉽게하고 네트워크 트래픽 최적화 하기 위해areas로 나누거나 구조화 할 수 있다
* Metric
  * 각 링크는 처리율, 왕복시간, 신뢰도 등등을 기반으로 가중치를 할당함
  * Hop count를 사용하면 RIP랑 같다.
* Areas
  * AS는 작은 구간으로 나눌 필요가 있다.
    * 라우팅을 효율적으로 처리하기 위해
    * LSP의 프러딩을 위한 독립적인 도메인으로 행동한다.
  * AS에서 한 Area는 backbone area로 작용한다.
* Router 유형
  * IR: area 내부의 라우터
  * ABR: area 경계에서 백본을 유지하기 위해 여러 area를 연결함
  * Backbone: AS의 모든 area는 백본가 연결되야한다.
  * ASBR: 여러 라우팅 프로토콜, 다른 AS와 연결
* LSA
  * LSDB의 정보를 각 링크의 이웃에게 알려준다.
  * 5개의 종류가 있다.
    * 라우터 링크, 네트워크 링크, 네트워크 링크 요약, AS 연결 요약, 외부 링크
* OSPF 패킷 종류
  * hello: greeting 종류
  * DB 설명: AS의 topology 정보가 들어있다.
  * 링크 상태 요청: 정보 업뎃요청
  * 링크 상태 업뎃: 정보 업데이트
  * 링크 상태 ACK: 업뎃 메시지 ACK

### BGPV4

* path-vector 라우팅
* iBGP
  * AS 내부의 세션을 만든다.
  * n개의 라우터면 n(n-1)/2개의 세션
  * i와 e의 차이는 다른 피어로의 전파차이이다.
    * e가 알아낸 새로운 루트는 모든 i와 e에게 분배한다.
* eBGP
  * BGP peers와 BGP Speakers라는 BGP 프로세스를 돌린다.
  * TCP, 179포트
* 인트라 도메인 라우팅에 정보 주입
  * BGP에 의해 수집되고 모아진 패스 테이블은 인트라 도메인 포워딩 테이블에 주입된다.
  * stub AS의 경계 라우터: 1개의 기본 엔트리로 추가됨
  * transient AS의 경계 라우터: 패스 테이블의 모든 내용이 추가됨
* path attributes
  * 다음 홉과 비용이 패스 attribute와 연관되있다.
  * 7가지나 있는데
* route 선택
  * 다양한 루트중에 한개 선택해야함
  * 루트는 각 기준에 맞게 추출됨

## 트랜스포트층

* 프로세스간에 통신
* 응용계층으로 서비스를 제공하는 층
* 포트 번호: 호스트는 IP로 프로세스는 포트로
  * 잘알려진 포트:0-1023
  * 등록된 포트: 1024-49151
  * 동적 또는 개인: 49153 - 65535
* 소켓 주소: IP+포트
* en캡 de캡
  * 메시지에 소켓주소와 정보 붙인다
* 멀티플렉싱 디멀티플렉싱
  * 멀티: 여러 아이템을 하나의 엔티티로
  * 디멀티: 하나의 엔티티를 여러 소스로
* 흐름 제어: 푸싱(흐름제어 요청), 풀링(데이터 더 줘)
  * 2개의 버퍼가 있다.(소비, 생산자 버퍼)
* 에러 제어
  * 네트워크 레이어는 불안정하다.
  * 에러있으면 버리고 다시 받는다
  * 이전 페킷을 저장한다. 패킷이 도착할때까지
* sequence numbers: modulo 2^m m은 SEQ 번호 부분의 크기
* ACK: 안전하게 도착하면 보내준다.
* 혼잡제어

### Sliding Window

* 2^m의 나머지를 사용

### 연결형, 비연결형

* 트랜스포트층의 연결은 패킷간의 의존성을 의미한다.
* 비연결은 순서 상관없음
* 연결형은 순서 상관있음

### 트랜스포트층 프로토콜

* 심플 프로토콜: 에러처리, 흐름 처리 없음
* stop and wait
  * 연결기반 프로토콜
  * 슬라이딩 윈도우가 1
  * 한개의 페킷을 보내고 ACK를 기다린다.
  * 체크섬추가
  * SEQ: 중복 방지를 위해서
  * ACK는 다음 페킷 번호
* Go-Back-N
  * 여러 페킷을 보낸다.
  * 근데 받는 버퍼는 1
  * SEQ 번혼는 2^m의 나머지
  * ACK는 축적을 시키고 다음 받아야하는 페킷번호 전달
  * send window 크기는 2^m-1 <- 1 크면 다시 보낸 패킷을 착각할수있다.
  * 타이머: 1개 있음, 타이머 초과 되면 다시보냄
  * 네트워크가 많은 패킷을 손실시키면 비효율적이다. <- 한개라도 잃으면 다시 모두 보내야하니까
* Selective Repeat
  * 다시 보내는 패킷을 정해서 보낼수있다.
  * 2^(m-1) send window 크기
  * 받는 윈도우도 같은 크기
  * 각 패킷마다 한개의 타이머, 그러나 대부분의 트랜스포트층은 한개의 타이머만 사용한다.
  * ACK: 에러 없었던 패킷번호를 보낸다
* TCP/IP 프로토콜: 이런 프로토콜을 수정하거나 조합해서 사용한다.

### bidirectional 프로토콜

* 위의 4개는 단방향
* 현실은 양방향
* 피기백: 양방향 통신의 효율을 높인다.

### UDP

* 간단한 비연결 프로토콜
* 오버헤드를 낮춤
* 유저데이터 그램
* 헤더: 8 바이트 4가지 필드로 구성됨
* 총 길이는 65535 <- Ip 데이터그램에 들어가야되서
* 65507바이트의 작은 메시지 전송함
* 체크섬은 옵션
* 큐는 포트와 관련됨
* DNS 서비스 : 짧은 요청과 빠른 반응이 필요, 1 메시지만 전달하면됨
* 내부적인 에러와 흐름 처리가 있는 프로세스거나 필요없는 경우 적합함
* 실시간으로 하려면

### TCP

* 연결형 프로토콜
* 윈도우와 흐름 에러 제어를 한다.
  * GBN이나 SR사용
  * 버퍼 필수
* 혼잡제어
* 바이트의 스트림
* 세그먼트
* full-duplex 통신
* 3-way handshaking
  * 처음
    * syn: 첫 seq 번호를 준다. seq 넘버 소비함
    * sys + ack: 다른 방향 SYN, 그리고 받는 윈도우 크기를 정한다.
    * ack: 보내는 윈도우 크기를 정한다. seq 넘버 안 소비함
  * 끝
    * FIN: 마지막 데이터 청크나 ACK가 들었다.
    * FIN + ACK: 마지막 청크가 들었을수도잇다.
    * ACK: 데이터 못 보냄
* syn flood 공격: 많은 syn 세그먼트를 보내는 공격
* 푸싱: 반응형 앱 때문에
* send and receive 윈도우
  * TCP는 한개 타이머
  * 윈도우 크기는 바이트의 개수다
* 흐름 제어
  * 윈도우의 shrinking으로 한다. 새로 받은 ack와 새로 rwnd가 더 크면 유지된다.
* 에러 제어: 체크섬, ACK, 타임아웃
  * SACK는 ACK를 대체하지는 않느데 보내는쪽에게 추가 정보를 제공한다.
  * 타임 아웃: 제송신 RTO 값은 RTT에 의해 결정된다.
  * 세그먼트의 3-duplicate ack가 도착하면 다음 세크먼트를 제송신한다.
* 세그먼트 순서
  * 순서가 안 맞는거 안버림
  * 잠시 저장해둠
  * 순서 맞춰서 프로세스에게 전달해줌
* 혼잡 제어
  * cwnd를 사용한다.
  * acks들을 통해 혼잡을 확인함
  * 타임아웃: ACK를 못받음
  * 중복 ACK
  * 3가지 정책
    * slow start: exponential(기하급수적) 증가, threshold까지 증가
    * congestion avoidance: 증가폭을 감소시킴, threshold부터는 1씩증가
    * Fast Recovery
      * 3-duplicate ACK 도착시: light 혼잡, 절반으로 줄이고 1씩 증가, cwnd의 절반
      * 타임아웃: 혼잡상황, slow start로 바꾼다. 위도우의 절반
  * 실제 윈도우 크기는 cwnd와 rwnd중 작은친구
* TCP의 타이머
  * retransmission
  * persistence
  * keepalive
  * time-wait

### SCTP

* UDP 처럼 메시지 기반이다.
* 좀더 신뢰성과 TCP처럼 순서가 있따.
* 여러 길을 사용하여 신뢰성과 회복력을 높였다.
